# 객체
## 1. 객체의 뜻
1. 객체지향언어 : "객체" 를 "지향" 하는 언어
2.  객체 : 사전적 의미로는 현실세계에서 독립적으로 존재하는 목적이 있고, 의미도 있는 모든 것들을 의미함 (유형, 무형, 개념, 사물, ..)
3. 객체지향프로그래밍 : 이 현실세계의 독립적인 존재들 (객체) 의 상호작용을 프로그래밍을 통해 가상세계 (코드) 로 구현하는 과정

### 결론적으로, 객체지향프로그래밍은 현실세계의 것을 프로그래밍으로 녹여 하나의 프로그램 (코드) 으로 만들어 내는 과정

- - - 

## 2. 현실세계를 코드로 구현하기

**1. 클래스라는 틀을 만들기 (1단계 추상화 + 2단계 캡슐화)**
**2.  "추상화" 과정 ( 현실세계의 것을 어떻게 프로그래밍 해볼건지 고민해보는 과정 )**
* 내가 만들고 싶은 프로그램이 뭔지 생각해보기
    * 학생관리 프로그램
	     * 내가 구현하고자 하는 프로그램에 필요한 객체들이 무엇이 있는지 생각해보기
       * 그 객체들이 가지고 있는 공통적인 정보 (속성), 행위 (기능, 동작) 들을 모두 추출해낼 것
       * 그렇게 추출한 것들을 가지고 내가 구현할 프로그램의 "실질적인 목적" 에 맞춰 불필요한 정보 및 행위들을 걷어낼 것 **(제일 중요!!)**
       * 최종적으로 추려진 것들을 가지고 어떤 자료형의 어떤 이름을 사용할 건지 생각해보기 (즉, 어떻게 코드로 짤건지 궁리하기)
       * 최종적으로 위의 내용을 가지고 프로그래밍 할 것!!


**3. 추상화 과정을 통해 위에 선정된 것들을 가지고 본격적인 프로그래밍을 해보자**
* "변수" 만을 가지고 프로그래밍을 하게된다면?
	 * 변수 : 하나의 자료형인 하나의 값만 보관할 수 있음!!
	    * 예) "홍길동 학생" 이라는 하나의 객체를 표현하기 위해서
       
```java
	       String name1 = "홍길동"; int age1 = 20; double height1 = 168.7;
	       String name2 = "김영희"; int age2 = 21; double height2 = 172.4;
	       String name3 = "김갑생"; int age3 = 22; double height3 = 183.9;
	       ...
```

> 수백명의 학생을 관리하는 프로그램을 구현해야 할 경우 수천 수만개의 변수가 생겨날 것임!! (관리하기 힘듦, 반복문 사용 불가)

- - -
  -  "배열" 을 이용해서 프로그래밍을 하게된다면?
	   * 배열 : 하나의 자료형인 여러개의 값들을 묶어서 보관할 수 있음!!
	     * 예) 학생들의 "이름" 만 보관할 수 있는 배열
 ``` java 
        String[] name = {"홍길동", "김영희", "김갑생", ...};
``` 
- 학생들의 "나이" 만 보관할 수 있는 배열
``` java
	 int[] age = {20, 21, 22, ...};
```
- 학생들의 "키" 만 보관할 수 있는 배열
``` java
   double[] height = {168.7, 172.4, 183.9, ...};
```
> 변수만 쓰는 것보다는 훨씬 나아보임!! (변수의 갯수도 줄어들고, 반복문 사용도 용이해짐)
> >  단, 인덱스 자릿 수만 학생마다 맞춰준다면... (0번 인덱스는 무조건 홍길동, 1번 인덱스에는 무조건 김영희, ...)
	 
> 만약에 한명의 학생이 전학을 가게 된다면? 
> > 해당 인덱스 자리의 학생 정보만을 정확하게 삭제해야함!! 

> 만약에 한명의 학생이 전학을 오게 된다면?
> > 정확하게 인덱스 수를 맞춰서 추가해줘야 하는것은 기본이고, (인덱스가 어그러지는 순간 데이터 불일치 현상도 일어남)
>  > > 배열의 특징 상 한번 지정된 크기는 절대 변경이 불가능함!! (더 큰 크기의 배열로 깊은복사 후 새로 추가해줘야함)  

**4. 구조체**
1) 구조체 : 한번에 여러개의 자료형을 보관할 수 있는 배열 같은 형태
* String 값도 보관하고, int 값도 보관하고, double 값도 보관하는 나만의 "배열같은 자료형" 을 하나 만들자!!
  * 자바에서는 이 구조체를 "클래스" 라고 부르기로 약속함!!
 
2) 클래스 : 각 객체들의 속성 정보를 담아내는 그릇과도 같은 존재
* 단순히 "메소드 (기능)" 를 정의하는 용도
  * 메소드 (기능) 위주의 클래스 : Controller 클래스
* 객체지향프로그래밍을 위해 정보들을 담는 용도의 클래스
  * 정보들을 담는 용도의 클래스 : VO (Value Object) 클래스

- - - 

## 3. 자바 클래스의 구조 
1. 필드부 :  "필드" 들이 모여있는 "부"분
> 필드 : 클래스 영역에 바로 정의된 변수 (메소드 밖에 정의된 변수)
> > "전역변수" 라고도 부름!!
**접근제한자 (예약어) 자료형 필드명;**

```java
	private String name;
	private int age;
	private double height;
```

> 필드의 접근제한자를 private 으로 바꿔주는게 캡슐화의 1단계임!!
	
2. 생성자부 : "생성자" 들이 모여있는 "부"분
	
3. 메소드부 : "메소드" 들이 모여있는 "부"분
>  메소드 : 각각의 기능을 담당하는 개념
* 표현법
	 * 우리는 평소에 메소드를 쓸 때 아래와 같이 씀!!
 
``` java 
	 public void 메소드명() {
	 
	 실행할 코드;
	  }
```
* 원래 메소드는 이렇게 표현함
```
	접근제한자 반환형 메소드명(매개변수 => 생략가능) {
실행할 코드;
}
```
	 
> 메소드 호출 시 필요로 하는 값을 넘길수도있고, (매개변수)
> > 메소드 실행이 끝난 뒤 필요하다면 값을 태초마을로 갖고 갈 수도 있음!! (반환형)


* 간접적으로나마 데이터를 기록 및 수정하는 용도의 메소드
	 * setter 메소드 : 외부로부터 값을 전달받아 (매개변수) 해당 필드에 대입해주는 메소드
     * 표현법
 
``` java
	 public void set필드명(해당필드와같은자료형 필드명) {
	 
	this.필드명 = 매개변수로써의필드명;
	}
```

> 매개변수의 이름은 해당필드명과 "동일" 하게 맞춰준다 (Naming Convention)
> > 매개변수명과 필드명이 일치하면 매개변수명이 필드명에 비해 우선순위가 더 높기 때문에 "필드로써의" 의미를 부여하려면 앞에 this. 을 작성한다!! (매개변수도 일종의 지역변수이기 때문)
	
* 간접적으로나마 데이터를 꺼내다주는 용도의 메소드
	* getter 메소드 : 이 필드에 들은 값을 외부로 내보내주겠다.
	  * 표현법
``` java
public 해당필드의자료형 get필드명() {
	 
	 	return 필드명;
}
```

> 반환형은 해당 필드값의 자료형, 반환값은 해당 필드에 들어있는 값이 된다!!
> > 마찬가지로 외부에서 호출이 가능해야하기 때문에 접근제한자는 public
> > > 단순히 역할이 필드값을 뽑아서 태초마을로 돌려주는거라 매개변수는 필요 없음


* 모든 필드값을 하나의 문자열로 연이어서 돌려주는 용도의 일반메소드
  
```
	public String information() {
		// return name, age, height;
		// 반환되는 결과값은 항상 반드시 한개 뿐이여야만 한다!!
		
		// 그래서 이 세개의 값을 하나의 문자열로 연이어준 다음 하나로 내보내겠다.
		return name + "님의 나이는 " + age + "살이고, 키는 " + height + "cm 입니다.";
	}
	
}
```

- - - 
### 4. "캡슐화" 과정을 통해 더 완벽한 클래스의 형태를 갖추게 하자
> 캡슐화를 하지 않으면 
> > 외부로부터 직접 접근이 가능하기 때문에 함부로 값이 변질되거나 함부로 값이 조회가 가능해지게 됨!!

예) 다른 학생이 김영희 학생의 정보를 보면 안됨 / 다른 학생이 김영희 학생의 정보를 수정해서도 안됨

> 그래서 캡슐화 작업을 반드시 해줘야 함!!
> > 객체지향 설계 원칙 중 하나가 "정보은닉", 정보은닉 기술 중 하나가 "캡슐화" (데이터은닉)

* 캡슐화 : 데이터의 접근 제한을 원칙으로 하여 외부로부터 직접 접근을 막자! 라는 컨셉임
* 
> 단, 대신에 간접적으로나마 값을 처리 (대입, 조회) 할 수 있게끔 조치는 취해두자!!

**1) 정보은닉 단계**

> 필드들을 외부로부터 직접 접근을 막기 위해 public 대신에 private 으로 바꿔쓰기
(접근제한자를 private 으로 바꾸기)

**2) setter / getter 메소드 작성**
* 간접적으로나마 접근해서 값을 담거나 (대입하거나, 변경하거나) 그 값을 가져올 수 있게끔 처리하는 과정
  	* setter 메소드 : 값을 필드에 담는 (셋팅해주는) 용도의 메소드
 	* getter 메소드 : 값을 필드로부터 가져올 수 있는 용도의 메소드
    
 > 이 2단계 간접적으로 풀어주는 과정까지 해야 비로소 캡슐화가 잘 되었다 라고 볼 수 있음!!

- - - 
### 5. 변수 구분
**1. 전역변수 (global variable)**
   * 클래스 영역 안에 곧바로 선언하는 변수
     * 해당 클래스 내에서는 어디서든 언제든지 사용 가능

**2. 지역변수 (local variable)**
   * 클래스 영역 내의 어떤 특정한 구역 ({ 여기 }) 안에 선언한 변수
     * 해당 중괄호 영역 ({ 여기 }) 안에서만 사용 가능
       * 예) 메소드 안의 변수, if문, for문

**3. 변수 종류에 따른 생성 및 소멸 시점**
* 전역변수
	 * 멤버변수 : 일반적인 전역변수 (필드, 인스턴스 변수)
	      * 생성시점 : new 연산자를 통해 해당 객체를 생성하는 순간 메모리 영역에 할당
	      * 소멸시점 : 해당 참조 주소값의 연결이 끊기고, 일정 시간이 지나면 알아서 소멸됨 (자동 메모리 관리)
	 * 클래스변수 : static 이라는 예약어가 붙은 전역변수 (static 변수)
	      * 생성시점 : 프로그램 시작과 동시에 메모리의 static 영역에 할당 (그래서 객체 생성을 new 연산자로 하지 않더라도 그냥 가져다 쓸 수 있게됨)
	      * 소멸시점 : 프로그램이 종료될 때 소멸됨
* 지역변수
	      * 생성시점 : 특정한 구역 ({ 여기 }) 내의 해당 변수 선언문 실행 시 생성됨
        * 소멸시점 : 특정한 구역 ({ 여기 }) 코드 흐름이 종료될 때 소멸됨

- - - 
### 6. 접근제한자 종류
* **(+)public**
	* : 어디서든 (같은패키지, 다른패키지든 모두) 모두 접근 가능하게 하고 싶다.
    
* **(#)protected**
	 * 같은 패키지면 무조건 접근 가능, 다른 패키지면 원칙상 접근 불가능 (즉, 같은 패키지에서만 접근 가능하게 하고 싶다) , "상속" 이라는 구조를 가진 클래스에서는 다른 패키지더라도 접근 가능하게 하고 싶다.
	  
* **(~)default**
	 * 오로지 같은 패키지에서만 접근 가능하게 하고 싶다.

* **(-)private**
	 * 오직 해당 클래스 영역 안에서만 접근 가능하게 하고 싶다.
 
- - - 

### 7. 필드부
**1.  필드 선언**
> 접근제한자 (예약어) 자료형 필드명;
> > 예약어는 생략 가능
  
**2. 클래스 변수 (static 변수) 선언 방법**
* 접근제한자 static 자료형 필드명;
> 예약어 자리에 static 이 들어가는 경우를 클래스 변수 또는 static 변수라고 부름
> > static 예약어가 붙는 순간, 클래스 변수 (static 변수) 로 취급됨


* 생성시점 : 프로그램 시작과 동시에 메모리의 Static 영역에 할당됨 (생성됨)
* 소멸시점 : 프로그램 종료되는 시점에 같이 소멸됨

 
**3. static**
* 프로그램 시작과 동시에 메모리영역에 미리 다 올려두고 두고두고 언제 어디서나 가져다 쓸 수 있다.
   *  static 은 "공유", "재사용" 의 의미가 강함 (주로 공통코드 작업 시 많이 쓰이나 주로 사용 X)
	    * 메모리 공간 효율을 위해 보통은 일반메소드, 일반멤버변수로 많이 쓴다!!

**4. 상수 필드 : 값을 변경할 수 없는 필드 (setter 메소드가 무의미해짐)**
* 표현법 
	 * public static final 자료형 변수명 = 값;
	   * 한번 지정된 값을 고정해서 공유해가면서 쓰겠다.
	   *  무조건 초기화 구문까지 같이 작성해야함!!
	   *  단, 예약어의 순서는 상관이 없음 (final static 이라고 써도 됨)
	 * static : 공유, 재사용의 의미
	 * final : 고정된 값의 의미 (상수)
   	 * 값이 변경되서는 안되는 고정적인 값을 메모리 상에 단 한번만 올려두고 공유해가면서 계속 사용할 목적
	   * 상수명은 항상 "대문자" 로

	 
